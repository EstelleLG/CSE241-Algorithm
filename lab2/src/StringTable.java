package lab2;
/**
 * A hash table mapping Strings to their positions in the pattern sequence.
 *
 * Fill in the methods for this class.
 */
public class StringTable {
	
	public int count; 
	Record[] Stringtable;
	public int size;
	Record delete = new Record("");
	
	
    /**
     * Create an empty table of size n
     *
     * @param n size of the table
     */
    public StringTable(int n) {
        // TODO: implement this method
    	count = 0;
    	size = n;
    	int m = n;
    	int i = 0;
    	while (m > 1) {
    		m /= 2;
    		i++;
    	}
    	int length = (int)Math.pow(2, i);
    	Stringtable = new Record[length];
    	
    }

    /**
     * Create an empty table.  You should use this construction when you are
     * implementing the doubling procedure.
     */
    public StringTable() {
        // TODO: implement this method
    	Stringtable = new Record[4];
    	count = 0;
    	size = 4;
    }

    /**
     * Insert a Record r into the table.
     *
     * If you get two insertions with the same key value, return false.
     *
     * @param r Record to insert into the table.
     * @return boolean true if the insertion succeeded, false otherwise
     */
    
    
    
    public boolean insert(Record r) {
        // TODO: implement this method
    	
    	if (count >=  (double) (Stringtable.length/4)) 
    		rehash();
    	
		int i = hash(r.getKey());
	
		if (Stringtable[i] != null)
		{
			if (Stringtable[i] == delete)
			{
				Stringtable[i] = r;
				count++;
				Stringtable[i].setHashKey(toHashKey(r.getKey()));
				return true;
			}
			else
				return false;
		}
		else  
		{
			Stringtable[i] = r;
			count++;
			Stringtable[i].setHashKey(toHashKey(r.getKey()));
			return true;
		}
    	
			
    	
		
    }

    /**
     * Delete a record from the table.
     *
     * Note: You'll have to find the record first unless you keep some
     * extra information in the Record structure.
     *
     * @param r Record to remove from the table.
     */
    public void remove(Record r) {
        // TODO: implement this method
    	
    	int i;    	
    	i = baseHash(toHashKey(r.getKey()));
    	while (Stringtable[i] != null) {
    		if (Stringtable[i] == r) {
    			Stringtable[i] = delete;
    			count --;
    			
    		}
    		else  {
    			i = (i + stepHash(toHashKey(r.getKey()))) % Stringtable.length;
    		}
    	}
    	
    	

    }

    /**
     * Find a record with a key matching the input.
     *
     * @param key to find
     * @return the matched Record or null if no match exists.
     */
    public Record find(String key) {
        // TODO: implement this method
    	int i; 	
    	i = baseHash(toHashKey(key));
    	while (Stringtable[i] != null) {
    		if (Stringtable[i].getHashKey() == toHashKey(key)) {
    			if((Stringtable[i].getKey()).equals(key)) {
    				return Stringtable[i];
    			}
    			else {
    				i = (i + stepHash(toHashKey(key))) % Stringtable.length;
				}
    		}
    		
    		else  {
    			i = (i + stepHash(toHashKey(key))) % Stringtable.length;
    		}
    	}
    	
    	return null;
    	
    	//if
    	
    }

    /**
     * Return the size of the hash table (i.e. the number of elements
     * this table can hold)
     *
     * @return the size of the table
     */
    public int size() {
        // TODO: implement this method
    	return size;
       
    }

    /**
     * Return the hash position of this key.  If it is in the table, return
     * the position.  If it isn't in the table, return the position it would
     * be put in.  This value should always be smaller than the size of the
     * hash table.
     *
     * @param key to hash
     * @return the int hash
     */
    public int hash(String key) {
        // TODO: implement this method
    	int i = baseHash(toHashKey(key));
    	int position = -1;
    	boolean meet = true;
    	while (Stringtable[i] != null) {
    		//put hashkey above
    		if (Stringtable[i].getHashKey() == toHashKey(key)) {
    			if ((Stringtable[i].getKey()).equals(key)){
    				return i;
    			}
    			else 
    				i = (i + stepHash(toHashKey(key))) % Stringtable.length;
    		}
    		else {
    			if (meet && Stringtable[i] == delete) {
    				position = i;
    				meet = false;
    			}
    			i = (i + stepHash(toHashKey(key))) % Stringtable.length;
    		}
    	}
    	if (position != -1) {
    		return position;
    	}
    	return i;
    }

    /**
     * Convert a String key into an integer that serves as input to hash functions.
     * This mapping is based on the idea of a linear-congruential pseuodorandom
     * number generator, in which successive values r_i are generated by computing
     *    r_i = (A * r_(i-1) + B) mod M
     * A is a large prime number, while B is a small increment thrown in so that
     * we don't just compute successive powers of A mod M.
     *
     * We modify the above generator by perturbing each r_i, adding in the ith
     * character of the string and its offset, to alter the pseudorandom
     * sequence.
     *
     * @param s String to hash
     * @return int hash
     */
    int toHashKey(String s) {
        int A = 1952786893;
        int B = 367253;
        int v = B;

        for (int j = 0; j < s.length(); j++) {
            char c = s.charAt(j);
            v = A * (v + (int) c + j) + B;
        }

        if (v < 0) {
            v = -v;
        }
        return v;
    }

    /**
     * Computes the base hash of a hash key
     *
     * @param hashKey
     * @return int base hash
     */
    int baseHash(int hashKey) {
        // TODO: implement this method
    	double a = (Math.sqrt(5)-1)/2;
    	double b = (hashKey * a) - (int)(hashKey * a);
    	int output = (int)(Stringtable.length * b);
    	return output;
    }

    /**
     * Computes the step hash of a hash key
     *
     * @param hashKey
     * @return int step hash
     */
    int stepHash(int hashKey) {
        // TODO: implement this method
      int a = (hashKey % (Stringtable.length-1));
      if (a % 2 == 0) 
    	  return a + 1;
      else 
    	  return a;
    }
    

    
    
///    
    Record[] tempTable;
    public void rehash(){
    	size = size *2;
    	tempTable = new Record[Stringtable.length *2];
    	
    	for (int i = 0; i < Stringtable.length; i++) {
    		if (Stringtable[i] != null && Stringtable[i] != delete) {
    			int newIndex = newHash(Stringtable[i].getKey());
    			tempTable[newIndex] = Stringtable[i];
    		}
    	}
    	
    	Stringtable = tempTable;
    	tempTable = null;
    }
    
    int tempBaseHash(int hashKey) {
        // TODO: implement this method
    	double a = (Math.sqrt(5)-1)/2;
    	double b = (hashKey * a) - (int)(hashKey * a);
    	return (int)(tempTable.length * b);
    }

    /**
     * Computes the step hash of a hash key
     *
     * @param hashKey
     * @return int step hash
     */
    int tempStepHash(int hashKey) {
        // TODO: implement this method
      int a = (hashKey % (tempTable.length-1));
      if (a % 2 == 0) 
    	  return a + 1;
      else 
    	  return a;
    }
    
    int newHash(String key) {
        // TODO: implement this method
    	int i = tempBaseHash(toHashKey(key));
    	while (tempTable[i] != null) {
    			i = (i + tempStepHash(toHashKey(key))) % tempTable.length;
    	}
    	return i;

    }
    
    
    
    
}